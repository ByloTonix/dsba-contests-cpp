/*
Известная утилита word2vec, основанная на нейронной сети, умеет приписывать каждому слову из словаря некоторый числовой вектор размерности N. При этом оказывается, что семантически «близким» словам соответствуют «близкие» векторы. Эта утилита находит широкое применение в задачах обработки естественного языка и машинного обучения.

В качестве меры «близости» между словами обычно выбирают угол между их векторами, косинус которого вычисляют по известной формуле

Однако часто векторы слов нормируют (чтобы их длина стала равна константе), и тогда в качестве меры близости рассматривают просто скалярное произведение

Чем это скалярное произведение больше, тем семантически «ближе» слова друг к другу.

Вам дан словарь из M слов, каждому из которых сопоставлен N-мерный вектор. Гарантируется, что все слова различны. Требуется найти в этом списке ближайшие слова к первому слову (кроме самого этого первого слова), используя в качестве метрики близости просто скалярное произведение.
Формат ввода

В первой строке через пробел записано 2 целых числа — M (2 ≤ M ≤ 100) и N (3 ≤ N ≤ 1000) — количество слов в словаре и размерность векторов соответственно.

Далее следует M строк, каждая из которых описывает очередное слово. Описание состоит из самого слова, длиной не более 15 символов, состоящего из строчных латинских букв, и набора из N целых чисел, разделенных пробелами. Компоненты вектора по модулю не превосходят 1000.
Формат вывода

Выпишите слова (по одному на строке), скалярное произведение векторов которых с вектором первого слова максимально. При этом скалярное произведение первого слова с самим собой учитывать не нужно. Если таких слов несколько, то их следует вывести в том же порядке, в котором они были даны на входе.
Пример
Ввод
Вывод

4 3
sweden 4 6 3
queen 0 2 2 
norway 4 7 5
king -1 3 2

	

norway
*/

#include <algorithm>
#include <iostream>
#include <vector>

int scalarProduct(const std::vector<int>& a, const std::vector<int>& b)
{
    int sum = 0;
    for (size_t i = 0; i < a.size(); ++i)
    {
        sum += a[i] * b[i];
    }
    return sum;
}

int main()
{
    size_t n, m;
    std::cin >> m >> n;

    std::vector<int> vec(n);
    std::string name;
    std::cin >> name;

    for (size_t i = 0; i < n; i++)
    {
        std::cin >> vec[i];
    }
    std::vector<std::pair<std::string, int>> words(m - 1);

    for (size_t i = 0; i < m - 1; i++)
    {
        std::cin >> words[i].first;
        std::vector<int> temp(n);
        for (size_t j = 0; j < n; j++)
        {
            std::cin >> temp[j];
        }
        words[i].second = scalarProduct(vec, temp);
    }

    int max = std::max_element(words.begin(), words.end(), [](const auto& a, const auto& b) { return a.second < b.second; })->second;

    for (const auto& word: words)
    {
        if (word.second == max)
        {
            std::cout << word.first << '\n';
        }
    }
}